@file:Suppress("UNCHECKED_CAST")

package org.jbali.branch

import org.jbali.bytes.theUnsafe
import kotlin.coroutines.Continuation

/**
 * Reflection helper for unwrapping Kotlin's [SafeContinuation] wrapper.
 *
 * When using [kotlin.coroutines.suspendCoroutine], Kotlin wraps the actual continuation
 * in a [SafeContinuation] for thread-safety. To clone continuations, we need access to
 * the underlying delegate continuation, which we obtain via reflection.
 */
object SafeCont {
    /** The SafeContinuation class */
    val clazz = Class.forName("kotlin.coroutines.SafeContinuation")

    /** Reflective access to the delegate field containing the actual continuation */
    val f_delegate = clazz.declaredFields.singleOrNull {
        it.name == "delegate"
    }
        .let { it
            ?: error("SafeContinuation must have a single delegate field")
        }
        .apply { isAccessible = true }
}

/**
 * Reflection-based wrapper around a continuation class, providing operations to
 * clone instances and manually invoke their suspension logic.
 *
 * Kotlin suspend functions compile to state machines represented as continuation classes.
 * This class provides low-level access to clone and manually resume these continuations.
 *
 * @param type The continuation class (usually a compiler-generated class for a suspend lambda).
 */
data class ContinuationClass(
    val type: Class<*>,
) {

    /**
     * All fields of the continuation, including inherited ones.
     *
     * Continuations store their local variables and state in fields. We need to copy
     * all of these to create a proper clone.
     */
    val fields by lazy { buildList {
        var c = type
        while (c != Any::class.java) {
            c.declaredFields.forEach {
                it.isAccessible = true
                add(it)
            }
            c = c.superclass
        }
    } }

    /**
     * The invokeSuspend method that implements the state machine logic.
     *
     * This method is generated by the Kotlin compiler and contains the actual logic
     * of the suspend function. It takes the resume value (Object) and returns either
     * [kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED] or the final result.
     */
    val invokeSuspend by lazy {
        type.methods.singleOrNull {
            it.name == "invokeSuspend" && it.parameterCount == 1
            && it.parameterTypes[0] == Object::class.java
        }
            .let { it
                ?: error("Missing $type invokeSuspend(Object)")
            }
    }

    /**
     * Creates a deep copy of a continuation by cloning its state.
     *
     * This uses [sun.misc.Unsafe.allocateInstance] to create an instance without calling
     * the constructor, then reflectively copies all field values from the original.
     * The result is a perfect snapshot of the continuation's state at that moment.
     *
     * Each clone can then be resumed independently with different values, allowing
     * exploration of multiple execution paths.
     *
     * @param cont The continuation to clone.
     * @return A new continuation instance with identical field values.
     */
    fun clone(cont: Continuation<*>): Continuation<*> {
        // Allocate instance without calling constructor (which may not be accessible)
        val clone = theUnsafe.allocateInstance(type) as Continuation<Any?>
        // Copy all fields from original to clone
        fields.forEach { it.set(clone, it.get(cont)) }
        return clone
    }

}